{"version":3,"file":"CanvasTextSystem.mjs","sources":["../../../../src/scene/text/canvas/CanvasTextSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":"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"}